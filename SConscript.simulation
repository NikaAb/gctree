#! /usr/bin/env python
# -*- coding: utf-8 -*-
'''Simulate tree'''
import os
from nestly import Nest
from nestly.scons import SConsWrap
from scipy import arange
# the following must be exported by parent SConstruct/SConscript
Import('env gctree igphyml outdir naive mutability substitution lambda_ lambda0 r frame N T n use_srun')

nest = Nest()
w = SConsWrap(nest, outdir, alias_environment=env)

if gctree:
    w.add_aggregate('gctree_agg', list)

# Initialize our first nest level,
if lambda_ is None:
    w.add('lambda', [1, 5, 10])
else:
    w.add('lambda', [lambda_])
if lambda0 is None:
    w.add('lambda0', [.1, .5, 1])
else:
    w.add('lambda0', [lambda0])
if r is None:
    w.add('r', [.1, .5, .9, 1.])
else:
    w.add('r', [r])
# next nest, just random simulation reruns, same params
w.add('runs', range(1, n+1))

@w.add_target()
def gctree_sim(outdir, c):
    '''
    GCtree simulation
    NOTE: xvfb-run is needed because of issue https://github.com/etetoolkit/ete/issues/101
    '''
    frame_arg = ' --frame {} '.format(frame) if frame is not None else ''
    T_arg = ' --T {} '.format(T) if T is not None else ''
    N_arg = ' --N {} '.format(N) if N is not None else ''
    return env.Command([os.path.join(outdir, 'gctree.simulation.fasta'),
                     os.path.join(outdir, 'gctree.simulation.collapsed_tree.p'),
                     os.path.join(outdir, 'gctree.simulation.log')],
                     [mutability, substitution],
                     'xvfb-run -a stdbuf -oL python bin/gctree.py simulate '+naive+
                     ' ${SOURCES[0]} ${SOURCES[1]}'+
                     ' --outbase '+os.path.join(outdir, 'gctree')+
                     ' --lambda {0[lambda]} --lambda0 {0[lambda0]} --r {0[r]}'.format(c)+
                     frame_arg+
                     T_arg+
                     N_arg+
                     ' > ${TARGETS[2]}')

@w.add_target()
def infer(outdir, c):
    '''now do inference on the simulation results'''
    fasta = c['gctree_sim'][0]
    naiveID = 'naive' # this is what the simulation routine names the naive
    return SConscript('SConscript.inference', exports='env gctree igphyml frame fasta outdir naiveID use_srun')

@w.add_target()
def validate(outdir, c):
    '''do validation'''
    outputs = [os.path.join(outdir, 'validation.tsv'), # <-- this one compares different methods
               os.path.join(outdir, 'validation.log')]
    if gctree:
        outputs.append(os.path.join(outdir, 'validation.gctree.tsv')) # <-- special gctree output evaluating parsimony tree ranking
    tgt = env.Command(outputs,
                   [c['gctree_sim'][1]] + [x[0] for x in c['infer']],
                    'stdbuf -oL python bin/validation.py $SOURCES --outbase '+os.path.join(outdir, 'validation')+' > ${TARGETS[1]}')
    if gctree:
        c['gctree_agg'].append(tgt[2])
    return tgt

w.pop('runs')

if gctree:
    @w.add_target()
    def gctree_aggregate(outdir, c):
        '''aggregate validation results'''
        tgt = env.Command([os.path.join(outdir, 'validaggreg.tsv'),
                           os.path.join(outdir, 'validaggreg.log')],
                          c['gctree_agg'],
                          'stdbuf -oL python bin/validaggreg.py $SOURCES --outbase '+os.path.join(outdir, 'validaggreg')+' > ${TARGETS[1]}')
        env.AlwaysBuild(tgt)
        return tgt
