#! /usr/bin/env python
# -*- coding: utf-8 -*-
'''Simulate tree'''
import os
from nestly import Nest
from nestly.scons import SConsWrap
from scipy import arange
# the following must be exported by parent SConstruct/SConscript
Import('env method outdir naive mutability substitution lambda_ lambda0 r frame N T')

nest = Nest()
w = SConsWrap(nest, outdir, alias_environment=env)

w.add_aggregate('aggdat', list)

# Initialize our first nest level,
if lambda_ is None:
    w.add('lambda', [1, 5, 10])
else:
    w.add('lambda', [lambda_])
if lambda0 is None:
    w.add('lambda0', [.1, 1, 10])
else:
    w.add('lambda0', [lambda0])
if r is None:
    w.add('r', [.1, .5, .9, 1.])
else:
    w.add('r', [r])
# next nest, just random simulation reruns, same params
w.add('runs', range(1,101))

@w.add_target()
def gctree_sim(outdir, c):
    '''
    GCtree simulation
    NOTE: xvfb-run is needed because of issue https://github.com/etetoolkit/ete/issues/101
    '''
    frame_arg = ' --frame {} '.format(frame) if frame is not None else ''
    T_arg = ' --T {} '.format(T) if T is not None else ''
    N_arg = ' --N {} '.format(N) if N is not None else ''
    return env.Command([os.path.join(outdir, 'gctree.simulation.fasta'),
                     os.path.join(outdir, 'gctree.simulation.collapsed_tree.p'),
                     os.path.join(outdir, 'gctree.simulation.collapsed_tree.svg'),
                     os.path.join(outdir, 'gctree.simulation.log')],
                     [mutability, substitution],
                     'xvfb-run -a stdbuf -oL python bin/gctree.py simulate '+naive+
                     ' ${SOURCES[0]} ${SOURCES[1]}'+
                     ' --outbase '+os.path.join(outdir, 'gctree')+
                     ' --lambda {0[lambda]} --lambda0 {0[lambda0]} --r {0[r]}'.format(c)+
                     frame_arg+
                     T_arg+
                     N_arg+
                     ' > ${TARGETS[3]}')

@w.add_target()
def infer(outdir, c):
    '''now do inference on the simulation results'''
    fasta = c['gctree_sim'][0]
    naiveID = 'naive' # this is what the simulation routine names the naive
    return SConscript('SConscript.inference', exports='env method frame fasta outdir naiveID')

@w.add_target()
def validate(outdir, c):
    '''do validation'''
    tgt = env.Command([os.path.join(outdir, 'validation.tsv'),
                       os.path.join(outdir, 'validation.pdf'),
                       os.path.join(outdir, 'validation.log')],
                      [c['gctree_sim'][1], c['infer'][0]],
                      'stdbuf -oL python bin/validation.py $SOURCES --outbase '+os.path.join(outdir, 'validation')+' > ${TARGETS[2]}')
    c['aggdat'].append(tgt[0])
    return tgt

w.pop('runs')

@w.add_target()
def aggregate(outdir, c):
    '''aggregate validation results'''
    tgt = env.Command([os.path.join(outdir, 'validaggreg.tsv'),
                       os.path.join(outdir, 'validaggreg.pdf'),
                       os.path.join(outdir, 'validaggreg.log')],
                      c['aggdat'],
                      'stdbuf -oL python bin/validaggreg.py $SOURCES --outbase '+os.path.join(outdir, 'validaggreg')+' > ${TARGETS[2]}')
    env.AlwaysBuild(tgt)
    return tgt
